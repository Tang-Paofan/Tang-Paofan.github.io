---
title: 事件循环-初探
mathjax: false
abbrlink: 1c597278
date: 2025-04-17 23:34:06
tags: 
 - Qt事件机制
categories:
 - Qt
---

随着对`Qt`的深入，必须要理解`Qt`事件循环是如何工作的，以下内容是个人对其的理解
<!-- less -->

## 概述
1. 主事件循环 `app.exec`
2. 可以进行事件分发、事件处理，包括键盘输入、鼠标点击、窗口重绘事件
3. `postEvent`的事件会先加入事件队列，在下一轮事件循环时处理->达到异步
4. `sendEvent`是立即同步执行
5. `exec` 会无限循环，在其后面的内容得不到运行，quit会终止事件循环

## 作用
1. **处理事件**: `QEventLoop` 通过不断地从事件队列中提取事件，并调用相应的事件处理器来处理这些事件。典型的事件包括键盘输入、鼠标点击、窗口重绘等
2. **更新 UI**: 在事件处理过程中，`QEventLoop` 会根据事件内容更新 UI。例如，当用户点击按钮时，事件循环会触发按钮的点击事件处理器，进而可能更新按钮的状态或执行其他 UI 操作
3. **维护应用程序的响应性**: `QEventLoop` 使得应用程序能够响应用户的交互。如果没有事件循环，应用程序将无法处理输入事件，UI 将变得不可操作

## 工作流程
1. **启动事件循环**: 当调用 `QCoreApplication::exec()` 或 `QApplication::exec()` 时，事件循环开始运行。
2. **处理事件队列**: 事件循环不断地从事件队列中提取事件并处理它们。
3. **调用事件处理器**: 对于每个事件，调用相应的事件处理器。例如，键盘事件会调用对应的键盘事件处理器。
4. **更新 UI**: 根据事件处理的结果更新 UI。例如，窗口重绘事件会触发窗口内容的重新绘制。

## 事件传递

## processEvents
1. 我们的UI界面，要持续不断地刷新（对于QWidget就是触发paintEvent事件），以保证显示流畅、能及时响应用户输入
2. 一般要有一个良好的帧率，比如每秒刷新60帧, 即经常说的FPS 60， 换算一下 1000 ms/ 60 ≈ 16 ms,也就是每隔16毫秒刷新一次。而我们有时候又需要做一些复杂的计算，这些计算的耗时远远超过了16毫秒
3. 在没有计算完成之前，函数不会退出（相当于阻塞），事件循环得不到及时处理，就会发生UI卡住的现象。这种场景下，就可以使用Qt为我们提供的接口，立即处理一次事件循环，来保证UI的流畅
```cpp
//耗时操作
doWork1()
//适当的位置，插入一个processEvents,保证事件循环被处理
QCoreApplication::processEvents();
 
//耗时操作
doWork2()
```

## 事件循环的嵌套
1. 事件循环可嵌套
2. 子事件在循环时，父事件处于中断状态
3. 子循环中也会有父循环的大部分事件，相当于接管了父事件
4. 如果某个子事件循环仍然有效，但其父循环被强制跳出，此时父循环不会立即执行跳出，而是等待子事件循环跳出后，父循环才会跳出
5. 父事件中嵌套了多个QEventLoop，每个 `QEventLoop` 都可以独立运行并处理自己的事件
    1. **独立运行**：每个 `QEventLoop` 独立处理其内部的事件，它们不会相互干扰。每个事件循环只处理通过其 `exec()` 方法启动的事件。
    2. **嵌套执行**：当一个 `QEventLoop` 启动时，它会阻塞当前线程，直到其 `quit()` 或 `exit()` 被调用。嵌套的事件循环可以在外层事件循环中启动，并独立运行。
    3. **事件处理顺序**：内层的事件循环会优先处理其事件，直到它退出为止。外层事件循环在内层事件循环退出后继续处理其事件。

## QEventLoop模拟同步
1. 模拟同步，但不会造成UI阻塞

主线程等待
```cpp
QEventLoop loop;
QTimer::singleShot(100, &loop, SLOT(quit()));
loop.exec();
```

## example
1. 非阻塞式线程运行，见[QEventLoop example](QThread.md#example)
## 参考文章
[Qt事件循环及QEventLoop的使用_qt qeventloop-CSDN博客](https://blog.csdn.net/kupepoem/article/details/121844578)
