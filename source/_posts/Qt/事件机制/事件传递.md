---
title: 事件传递
mathjax: false
date: 2025-04-22 23:05:23
tags: 
 - Qt事件机制
categories:
 - Qt
---

继事件循环之后，本文探讨事件在控件之间如何传递
<!-- less -->

## 概述
1. Qt 事件传递顺序如下

![](https://cdn.jsdelivr.net/gh/Tang-Paofan/Asset/BlogPicture/Pasted%20image%2020250102152416.png)

## 事件类型
Qt程序是事件驱动的，程序的每个动作都是由幕后某个事件所触发。 Qt事件的类型很多，常见的qt的事件如下:
- 键盘事件: 按键按下和松开
- 鼠标事件: 鼠标移动，鼠标按键的按下和松开
- 拖放事件: 用鼠标进行拖放
- 滚轮事件: 鼠标滚轮滚动
- 绘屏事件: 重绘屏幕的某些部分
- 定时事件: 定时器到时
- 焦点事件: 键盘焦点移动
- 进入和离开事件: 鼠标移入widget之内，或是移出。
- 移动事件: widget的位置改变
- 大小改变事件: widget的大小改变
- 显示和隐藏事件: widget显示和隐藏
- 窗口事件: 窗口是否为当前窗口。

还有一些非常见的qt事件，比如socket事件，剪贴板事件，字体改变，布局改变等等
Qt 的event和signal不一样。
1. 后者通常用来”使用”widget，而前者用来”实现” widget
    1. 比如一个按钮，我们使用这个按钮的时候，我们只关心他clicked()的signal，至于这个按钮如何接收处理鼠标事件，再发射这个信号，我们是不用关心的
2. 但是如果我们要重载一个按钮的时候，我们就要面对event了
    1. 比如我们可以改变它的行为，在鼠标按键按下的时候(mouse press event) 就触发clicked()的signal而不是通常在释放的( mouse release event)时候

## 事件的产生
1. 系统产生的
    1. 通常是window system把从系统得到的消息，比如鼠标按键，键盘按键等，放入系统的消息队列中。 Qt事件循环的时候读取这些事件，转化为QEvent，再依次处理
2. 由Qt应用程序程序自身产生的
    1. 程序产生事件有两种方式，一种是调用QApplication::postEvent()。 例如QWidget::update()函数，当需要重新绘制屏幕时，程序调用update()函数，new出来一个paintEvent，调用 QApplication::postEvent()，将其放入Qt的消息队列中，等待依次被处理。 另一种方式是调用sendEvent()函数。 这时候事件不会放入队列，而是直接被派发和处理，QWidget::repaint()函数用的就是这种方式。
    2. 自定义事件

## 事件的调度
见[事件循环-再探](事件循环-再探.md)

1. Qt的事件循环是异步的，当调用QApplication::exec()时，就进入了事件循环
2. 先处理Qt事件队列中的事件，直至为空。 再处理系统消息队列中的消息，直至为空，在处理系统消息的时候会产生新的Qt事件，需要对其再次进行处理
3. 调用QApplication::sendEvent的时候，消息会立即被处理，是同步的。 实际上QApplication::sendEvent()是通过调用QApplication::notify()，直接进入了事件的派发和处理环节

## 事件派发
事件过滤器见[事件过滤器](事件过滤器.md)

1. Qt中，事件的派发是从 QApplication::notify() 开始的，因为QAppliction也是继承自QObject，所以先检查QAppliation对象，如果有事件过滤器安装在qApp上，先调用这些事件过滤器。 **接下来QApplication::notify() 会过滤或合并一些事件(比如失效widget的鼠标事件会被过滤掉，而同一区域重复的绘图事件会被合并)**。 之后，事件被送到reciver::event() 处理。
2. 同样，在reciver::event()中，先检查有无事件过滤器安装在reciever上。 若有，则调用之。 接下来，根据QEvent的类型，调用相应的特定事件处理函数。 一些常见的事件都有特定事件处理函数，比如:mousePressEvent()，focusOutEvent()，resizeEvent()，paintEvent()，resizeEvent()等等。 在实际应用中，经常需要重载这些特定事件处理函数在处理事件。 但对于那些不常见的事件，是没有相对应的特定事件处理函数的。 如果要处理这些事件，就需要使用别的办法，比如重载event() 函数，或是安装事件过滤器。
![](https://cdn.jsdelivr.net/gh/Tang-Paofan/Asset/BlogPicture/Pasted%20image%2020250105180417.png)

## 事件转发
1. 对于某些类别的事件，如果在整个事件的派发过程结束后还没有被处理，那么这个事件将会向上转发给它的父widget，直到最顶层窗口。
2. _如何判断一个事件是否被处理了呢_? Qt中和事件相关的函数通过**两种方式**相互通信。 
    1. QApplication::notify()，QObject::eventFilter()，QObject::event() 通过返回bool值来表示是否已处理。 “_**真**_”表示已经处理，“_**假**_”表示事件需要继续传递。
    2. 另一种是调用QEvent::ignore() 或 QEvent::accept() 对事件进行**标识**。 这种方式只用于event() 函数和特定事件处理函数之间的沟通。 而且只有用在某些类别事件上是有意义的，这些事件就是上面提到的那些会被转发的事件，包括: 鼠标，滚轮，按键等事件。
   
### 父子事件传递
1. 子控件的事件处理中默认是`accept`的
2. 子控件的事件处理设置为`ignore`，事件将会向父控件传递
3. 子控件如果已经重写事件处理函数（没有执行`ignore`），那么无法传递到父控件
4. 子控件如果设置了事件过滤器`installEventFilter`，那么事件过滤器会优先过滤事件

> other blog
> 1. 如果子控件没有accept或ignore事件，那么该事件将会被传递到父控件
> 2. 对于一个继承而来的类，只要我们重写实现了其各个事件处理函数，则对应的事件肯定无法传递给其父widget，哪怕重写的该事件处理函数的函数体为空
> 3. 如果是标准的控件对象，则其肯定没重写各个事件处理函数，那消息能不能传递到父widget中，则取决于中途有没有使用事件过滤器等将该信号拦截下来了

#### `event->ignore()`
`event->ignore()` 是一种指示事件没有被处理的方式。调用此函数后，事件会继续传播到父对象，或者如果它在事件队列中，它会被其他事件处理器处理。一般用于：
- **避免处理事件**：当你不希望处理特定事件时。
- **传播事件**：允许其他组件或父级处理该事件。

#### `event->accept()`
`event->accept()` 用于标记事件已被成功处理。调用此函数后，事件处理过程会停止，不会再传递给其他组件或父级。一般用于：
- **确认事件处理**：表示当前对象已经处理了该事件，无需进一步处理。
- **防止传播**：阻止事件传播到其他组件或父级。

`ignore`和`accept`返回值均为`void`，因此只能用于具体事件处理中（没有返回值的事件处理）

## 参考文章
[【转】QT事件传递与事件过滤器-阿里云开发者社区](https://developer.aliyun.com/article/308755)